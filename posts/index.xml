<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on GetArmed!</title>
    <link>https://wy-luke.github.io/posts/</link>
    <description>Recent content in Posts on GetArmed!</description>
    <image>
      <url>https://wy-luke.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://wy-luke.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 18 Sep 2022 17:18:10 +0800</lastBuildDate><atom:link href="https://wy-luke.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C&#43;&#43; 处理输入</title>
      <link>https://wy-luke.github.io/posts/cpp-input/</link>
      <pubDate>Sun, 18 Sep 2022 17:18:10 +0800</pubDate>
      
      <guid>https://wy-luke.github.io/posts/cpp-input/</guid>
      <description>1. 输入一个数 int a; cin &amp;gt;&amp;gt; a; 2. 连续输入一个数 int a; while (cin &amp;gt;&amp;gt; a) { } 3. 按行读取 每次读取一行输入，包含空格，已回车换行结束
string input; while (getline(cin, input)) { } 4. 按行读取后，提取每行的字符串 字符串之间用空格间隔 string input; while (getline(cin, input)) { istringstream iss(input); string str; // &amp;#34;&amp;gt;&amp;gt;&amp;#34;会忽视字符串之间所有的回车和空格，即每次读取一个有效字符串输入 // 在这里 iss 是每行的输入，不包含回车，所以 &amp;#34;&amp;gt;&amp;gt;&amp;#34; 会忽视掉字符串中间的所有空格 while(iss &amp;gt;&amp;gt; str) { } } 字符串之间用逗号（或其他任意字符）间隔 string input; while (getline(cin, input)) { istringstream iss(input); string str; // 提取分隔符之间的字符串，注意这里提取出的可以是空字符串 // 若 &amp;#34;a,,b&amp;#34; 则提取出 a b 和一个空字符串 // 同时，若以间隔符结尾，则不会再记入一个空字符串 // 若 &amp;#34;,,&amp;#34; 则提取出 2 个空字符串 while(getline(iss, str, &amp;#39;,&amp;#39;)) { } } </description>
    </item>
    
    <item>
      <title>深挖数字的二进制表示与运算溢出</title>
      <link>https://wy-luke.github.io/posts/numbers/</link>
      <pubDate>Tue, 30 Aug 2022 20:01:50 +0800</pubDate>
      
      <guid>https://wy-luke.github.io/posts/numbers/</guid>
      <description>基本概念 首先说明一下三个名词：
原码：一个整数，按照绝对值大小转换成的二进制数，称为原码。
反码：将二进制数按位取反，所得的新二进制数称为原二进制数的反码。
补码：反码加 1 称为补码。
在计算机中，数字是以二进制形式储存的，如一个 int 为 4 字节，32 位，即可以 32 位二进制数表示
数字又分为有符号（signed）和无符号（unsigned），即正负
对于有符号类型，由第一位二进制数表示正负，0 表示正，1 表示负
所以一个正数，其存储形式就是第一位 1 加上该正数的二进制
而负数则是以其正值的补码形式表示（第一位 0 在这个过程就变成了 1）
而对于无符号类型，不再使用第一位表示符号，所有位均用于存储数据，所以无符号类型比有符号类型的数值上限大两倍左右
INT_MAN = (2^31)-1, UINT_MAX = (2^32)-1
-1 是因为 0 的存在
计算过程的溢出 无符号在溢出时，自动根据其位数取模
对此 C/C++ 的规范是有定义的，“溢出后的数会以2^(8*sizeof(type))作模运算”，也就是说，如果一个 unsigned char（1 字符，8 bits）溢出了，会把溢出的值与 2^8=256 取模，int 溢出则是与 2^32 取模
对于 signed 整型的溢出，C/C++ 的规范定义是“undefined behavior”，虽然没有定义，各编译器可自己实现，但是大部分的溢出机制都是一样的
有符号整型溢出又可分为向上溢出和向下溢出。假设用 k 个字节表示一个整型变量, 那么这个变量可以表示的有符号整数的范围是-2^(8k-1) ~ 2^(8k-1) – 1,那么两个正整数或者两个负整数相加就有可能超过这个整型变量所能表示的范围, 向上超出&amp;gt;2^(8k-1) – 1我们称之为向上溢出, 向下超出&amp;lt;-2^(8k-1), 我们称之为向下溢出
对于signed char,正整数最大值为127，负整数最小值为128。unsigned char所能表示的最大值为255</description>
    </item>
    
    <item>
      <title>Java 中基本类型与引用类型的深拷贝和浅拷贝</title>
      <link>https://wy-luke.github.io/posts/deep-shallow-copy/</link>
      <pubDate>Wed, 10 Aug 2022 10:02:26 +0800</pubDate>
      
      <guid>https://wy-luke.github.io/posts/deep-shallow-copy/</guid>
      <description>数据分为基本数据类型和引用数据类型
众所周知，（一般）变量是存在栈中的
基本数据类型的变量：数据直接存储在栈中 引用数据类型的变量：栈中存储的是一个指针，指向堆中的一块内存，真实的数据存放在堆内存里
对于一般拷贝操作而言，就是把栈中的数据拷贝一份，内容和原来一样
基本类型 所以，对于基本类型，由于数据直接存储在栈中，拷贝一份就意味着把数据拷贝了一份
比如int x = 4，那么栈中就有一块内存储存了4，int y = x就是在栈中新建一个变量(一块内存)，并拷贝源数据，即4，
所以此时栈中有两块内存储存的都是4，一个是x一个是y，更改x的值不会影响y，反之同样
所以基本类型默认就是深拷贝
那么，对于基本类型，怎么实现浅拷贝呢？C++在某种意义上实现可以通过指针或引用实现，而Java没有指针，所以并不太好实现，可以参考这里
引用类型 对于引用类型就不太一样了，int[] x = new int[] {1,2}时，在栈中有一个变量x，指向堆内存中的数组
int[] y = x时，复制栈中的数据，也就是说，在栈中新建了一个指针y，和x指向同一块堆内存，也就是刚才的数组
所以此时栈中有两块内存储存的都是指针，一个是x一个是y，但是指向同一块堆内存，更改x的值，如x[1] = 2，y的值也会发生改变
这就是浅拷贝，所以java引用类型默认是浅拷贝
而深拷贝是要在栈中新建一个变量的同时，并且在堆中也新建一块内存，把要复制的值存进去，并将在栈中新建的变量指向堆中新建的内存
即： 浅拷贝：在栈中新建一个变量，还是指向同一块内存 深拷贝：在栈中新建一个变量，并且在堆中也新建一块内存，把要复制的值存进去，将在栈中新建的变量指向堆中新建的内存
那么，既然用=复制是浅拷贝，怎样能够实现深拷贝呢？
对于数组，当然可以通过.clone()
int[] src = ... int[] dest = src.clone(); 对于class，一种比较安全的方法是先序列化，然后反序列号，可以参考这里
特殊的 String 类型 Java中的String类型比较特殊，虽然他是引用类型，但是他具有不可变性，也就是说，在堆内存中的一块String，如&amp;quot;hello&amp;quot;，内容是不能更改的
string x = &amp;quot;hello&amp;quot;后，再改变x的值：x=&amp;quot;world&amp;quot;，会在堆内存中重新划一块内存，储存&amp;quot;world&amp;quot;，并将x指向新内存，原有内存后续如果没有被引用就会被清理掉（垃圾回收）
然而，若我们string x = &amp;quot;hello后string y = x，y和x指向同一块堆内存&amp;quot;hello&amp;quot;，但是如上一段所说，x=&amp;quot;world&amp;quot;会在堆中新建一块内存，而不是更改原有内存的数据，也就是说，现在，x指向world，而y依然指向hello
所以对String虽然是引用类型，但是直接使用=等号，是深拷贝
更详细的证明见这里</description>
    </item>
    
    <item>
      <title>C&#43;&#43; STL 二分 lower_bound / upper_bound 用法详解</title>
      <link>https://wy-luke.github.io/posts/binary-search/</link>
      <pubDate>Wed, 25 May 2022 14:44:19 +0800</pubDate>
      
      <guid>https://wy-luke.github.io/posts/binary-search/</guid>
      <description>假设我们要在一个 vector&amp;lt;int&amp;gt; 中，查找一个数 value
语法 auto p = std::lower_bound(v.begin(), v.end(), value) auto p = std::upper_bound(v.begin(), v.end(), value) 返回的值类型是 iterator 即迭代器，理解为指针即可
定义 lower_bound 获取第一个大于等于value的指针
is not less than
upper_bound 获取第一个大于 value的指针
is greater than value
用法详解 由上可以引申出多种用法：
要查找的每个数都存在时，如果这个数只存在一次 lower_bound 和 upper_bound - 1 结果一样，同样指向该数，upper_bound 指向第一个大于value的数
要查找的每个数都存在时，如果这个数存在多次 lower_bound 能查找到左侧边界，upper_bound - 1 能查找到右侧边界
要查找的数不在时 lower_bound 和 upper_bound 结果一样，同样指向第一个大于value的数
引申 STL 里面还有一个 equal_range()，就是返回一个pair，分别为 lower_bound 和 upper_bound 的结果
可以理解为一个左闭右开 [start, end) ，区间为要查找的 vector 里面，等于 value 的部分</description>
    </item>
    
    <item>
      <title>为什么 int 类型最大值为 2^31-1，最小值为 -2^31</title>
      <link>https://wy-luke.github.io/posts/int-range/</link>
      <pubDate>Tue, 24 May 2022 00:02:53 +0800</pubDate>
      
      <guid>https://wy-luke.github.io/posts/int-range/</guid>
      <description>一个 int 占 4 字节（Byte），也就是 32 位（Bit），其中第一位用来存储正负号，1 表示负数，0 表示正数
也就是说，共有 31 位用来存储数据，所以，能够存储数字的总个数为 2^31=2147483648 （10^9）
而在某种程度上，可以理解为，在存储上，0 被归为了正数
所以正数最大值为 2^31-1，而负数最小值就是2^31
更形象的解释看下面：
Int32.MaxValue = 2^31 - 1 = 01111111111111111111111111111111 1 = 00000000000000000000000000000001 0 = 00000000000000000000000000000000 -1 = 11111111111111111111111111111111 Int32.MinValue = -2^31 = 10000000000000000000000000000000 可以明显的看出，为什么 int 类型最大值为 2^31-1，而最小值是2^31</description>
    </item>
    
    <item>
      <title>WPF 获取主窗口 MainWindow 实例，以及其中的控件</title>
      <link>https://wy-luke.github.io/posts/wpf-get-mainwindow/</link>
      <pubDate>Wed, 18 May 2022 15:20:39 +0800</pubDate>
      
      <guid>https://wy-luke.github.io/posts/wpf-get-mainwindow/</guid>
      <description>由于WPF执行的方式有些奇怪，并不是一般意义上的 “类&amp;ndash;实例化”
所以如果你想要在其他 Class 文件、或其他窗口中，执行 MainWindow 中的一些函数时；或者是想要获取 MainWindow 的某个控件，并对其操作时（比如你要在一个新的窗口中，改变 MainWindow 的一个 Switch 的开关状态），就非常麻烦
你可以把需要使用的函数定义为 静态（Static），但是这样带来的限制非常多，而且这种方法不适用与获取控件
经查阅，只需一行代码：
var _mainWindow = Application.Current.Windows .Cast&amp;lt;Window&amp;gt;() .FirstOrDefault(window =&amp;gt; window is MainWindow) as MainWindow; Application.Current contains a collection of all windows in your application, you can get the other window with a query such as
然后就可以对 MainWindow 中的任何函数或控件进行操作了，如：
_mainWindow.Switch1.IsOn = false; 此时函数也无需定义为 静态（Static）了，非常方便。
同理也适用于获取其他窗口，只需要将上面代码的 MainWindow 改为你需要寻找的窗口名即可
参考链接: https://stackoverflow.com/questions/13644114/how-can-i-access-a-control-in-wpf-from-another-class-or-window/44988191#44988191</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 自定义排序顺序详解，优先级队列 &#43; lambda 表达式</title>
      <link>https://wy-luke.github.io/posts/custom-sort/</link>
      <pubDate>Sun, 27 Mar 2022 21:41:03 +0800</pubDate>
      
      <guid>https://wy-luke.github.io/posts/custom-sort/</guid>
      <description>1. C++ named requirements ( 具名要求 ) : Compare C++ 中没有 Comparator 类，Campare 是一个 requirement ，可以理解为一种定义，要求。
yields true if the first argument of the call appears before the second in the strict weak ordering relation induced by this type, and false otherwise.
人话来讲，比较两个参数，返回 bool 值，当返回 true 时，第一个参数排在第二个参数前面，即第一个参数先进入 Container（如 vector ）
注意这里只关心返回 true 时的情况， 当两个参数相等（即无排序要求）和第一个参数在后面、第二个参数在前面时，都返回 false，在自定义 Campare 时需要注意这一点！！！
也就是说，在自定义 Campare 时，当第一个参数排在第二个参数前面时，返回 true ，其他情况均返回false
所以，在排序时，如果要保持相等元素的相对位置，即稳定排序，要用stable_sort()
否则，用sort()即可（不能保证相等元素相对位置不变）
2. std::greater std::less std::greater : 当第一个参数大于第二个参数时，返回 true</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 生成指定范围随机数的方法总结</title>
      <link>https://wy-luke.github.io/posts/cpp-random/</link>
      <pubDate>Sun, 27 Mar 2022 15:51:03 +0800</pubDate>
      
      <guid>https://wy-luke.github.io/posts/cpp-random/</guid>
      <description>1. rand() rand() % max 可以生成 [0, max) 范围的随机数，则
// 生成 [0, max] int x = rand() % (max + 1); // 生成 [1, max + 1) ，即 [1, max] int x = 1 + rand() % (max); // 生成 [min, max] 范围的随机数 int x = min + rand() % (max - min + 1); 2. STL 以下套用即可，具体解释见 cppreference
std::random_device rd; //Will be used to obtain a seed for the random number engine std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd() std::uniform_int_distribution&amp;lt;&amp;gt; distrib(1, 6); // 指定范围 // Use `distrib` to transform the random unsigned int generated by gen into an int in [1, 6] // 生成 [1, 6] 范围的随机数 std::cout &amp;lt;&amp;lt; distrib(gen) &amp;lt;&amp;lt; endl; </description>
    </item>
    
    <item>
      <title>C# 正则表达式匹配特定字符然后做任意处理，并保留字符位置</title>
      <link>https://wy-luke.github.io/posts/cs-pick-custom-char/</link>
      <pubDate>Wed, 15 Dec 2021 15:47:37 +0800</pubDate>
      
      <guid>https://wy-luke.github.io/posts/cs-pick-custom-char/</guid>
      <description>针对稍简单的操作，一行代码即可搞定
string text = &amp;#34;abcabc&amp;#34;; // Regex.Replace 的第一个参数为要处理的字符串，第二个为正则表达式，第三个为你的操作 // 匹配字符串中所有的 a，然后转为大写。m.Value 即为匹配到的字符 text = Regex.Replace(text, &amp;#34;[a]&amp;#34;, m =&amp;gt; m.Value.ToUpper()); Console.WriteLine(text); &amp;gt;&amp;gt;&amp;gt;&amp;#34;AbcAbc&amp;#34; 针对更复杂的操作，可以专门写一个函数
private static string ReplaceMethod(Match m) { // m.ToString() 即为匹配到的字符，可做任意处理 return m.ToString().ToUpper(); } private static void Main() { var text = &amp;#34;abcabc&amp;#34;; var myEvaluator = new MatchEvaluator(ReplaceMethod); text = Regex.Replace(text, &amp;#34;[a]&amp;#34;, myEvaluator); Console.WriteLine(text); } &amp;gt;&amp;gt;&amp;gt;&amp;#34;AbcAbc&amp;#34; </description>
    </item>
    
    <item>
      <title>Python中列表截取（Slice，即冒号 : ）的用法详解</title>
      <link>https://wy-luke.github.io/posts/python-slice/</link>
      <pubDate>Tue, 13 Jul 2021 22:20:32 +0800</pubDate>
      
      <guid>https://wy-luke.github.io/posts/python-slice/</guid>
      <description>1. 基本用法 a[start:stop] # 从 index=start 开始（即包含start），到 index=stop-1（即不包含stop） a[start:] # 从 index=start 开始（包含 start ），到最后 a[:stop] # 从头开始，到 stop-1 a[:] # 取整个 List 注意：
结束的 index （索引值） 是 stop-1 ，也就是说不包含 index=stop 的那个值 我这里说的 index 是索引值，从 0 开始，这个大家应该都知道 a[1:4] # 从 index=1 取到 index=4 a[1:] # 从 index=1 取到最后 a[n, start:stop] # 对一个二维 List，取第 n 行，从 index=start 到 index=stop-1 间的列 具体示例：
&amp;gt;&amp;gt;&amp;gt; a = [1,2,3,4,5,6] &amp;gt;&amp;gt;&amp;gt; a[1:4] [2, 3, 4] &amp;gt;&amp;gt;&amp;gt; a[1:] [2, 3, 4, 5, 6] 2.</description>
    </item>
    
  </channel>
</rss>
