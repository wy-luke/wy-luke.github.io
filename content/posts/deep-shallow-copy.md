---
title: "Java 中基本类型与引用类型的深拷贝和浅拷贝"
date: 2022-08-10T10:02:26+08:00
tags: ["Java"]
---

数据分为**基本数据类型**和**引用数据类型**

众所周知，（一般）变量是存在栈中的

**基本数据类型**的变量：数据直接存储在栈中
**引用数据类型**的变量：栈中存储的是一个指针，指向堆中的一块内存，真实的数据存放在堆内存里

对于一般拷贝操作而言，就是把**栈**中的数据拷贝一份，内容和原来一样

## 基本类型

所以，对于**基本类型**，由于数据直接存储在栈中，拷贝一份就意味着把数据拷贝了一份

比如`int x = 4`，那么栈中就有一块内存储存了`4`，`int y = x`就是在栈中新建一个变量(一块内存)，并拷贝源数据，即`4`，

所以此时栈中有两块内存储存的都是`4`，一个是x一个是y，更改x的值不会影响y，反之同样

所以基本类型默认就是**深拷贝**

那么，对于基本类型，怎么实现浅拷贝呢？C++在某种意义上实现可以通过指针或引用实现，而Java没有指针，所以并不太好实现，可以[参考这里](https://stackoverflow.com/questions/39997078/shallow-copy-integer-in-java)

## 引用类型

对于**引用类型**就不太一样了，`int[] x = new int[] {1,2}`时，在栈中有一个变量`x`，指向堆内存中的数组

`int[] y = x`时，复制栈中的数据，也就是说，在栈中新建了一个指针`y`，和`x`指向同一块堆内存，也就是刚才的数组

所以此时栈中有两块内存储存的都是指针，一个是x一个是y，但是指向同一块堆内存，更改x的值，如`x[1] = 2`，y的值也会发生改变

这就是**浅拷贝**，所以`java`引用类型默认是**浅拷贝**

而**深拷贝**是要在栈中新建一个变量的同时，并且在堆中也新建一块内存，把要复制的值存进去，并将在栈中新建的变量指向堆中新建的内存

即：
**浅拷贝**：在栈中新建一个变量，还是指向同一块内存
**深拷贝**：在栈中新建一个变量，并且在堆中也新建一块内存，把要复制的值存进去，将在栈中新建的变量指向堆中新建的内存

那么，既然用`=`复制是**浅拷贝**，怎样能够实现深拷贝呢？

对于数组，当然可以通过`.clone()`

```Java
int[] src = ...
int[] dest = src.clone();
```

对于class，一种比较安全的方法是先序列化，然后反序列号，可以[参考这里](https://stackoverflow.com/questions/64036/how-do-you-make-a-deep-copy-of-an-object)

## 特殊的 String 类型

Java中的String类型比较特殊，虽然他是引用类型，但是他具有**不可变性**，也就是说，在堆内存中的一块String，如`"hello"`，内容是不能更改的

`string x = "hello"`后，再改变x的值：`x="world"`，会在堆内存中重新划一块内存，储存`"world"`，并将x指向新内存，原有内存后续如果没有被引用就会被清理掉（垃圾回收）

然而，若我们`string x = "hello`后`string y = x`，y和x指向同一块堆内存`"hello"`，但是如上一段所说，`x="world"`会在堆中新建一块内存，而不是更改原有内存的数据，也就是说，现在，x指向world，而y依然指向hello

所以对String虽然是引用类型，但是直接使用`=`等号，是**深拷贝**

更详细的证明见[这里](https://stackoverflow.com/questions/10607990/how-should-i-copy-strings-in-java)
