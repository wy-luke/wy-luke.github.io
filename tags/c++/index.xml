<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>C&#43;&#43; on GetArmed!</title>
    <link>https://wy-luke.github.io/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on GetArmed!</description>
    <image>
      <url>https://wy-luke.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://wy-luke.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 05 Oct 2022 19:43:51 +0800</lastBuildDate><atom:link href="https://wy-luke.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C&#43;&#43; 中的各种 find</title>
      <link>https://wy-luke.github.io/posts/cpp-find/</link>
      <pubDate>Wed, 05 Oct 2022 19:43:51 +0800</pubDate>
      
      <guid>https://wy-luke.github.io/posts/cpp-find/</guid>
      <description>C++ 中 find 主要分为两种
一种是 string 里封装的，只能针对 string 搜索，返回类型是 int 下标，没搜到时返回 string::npos
一种是 &amp;lt;algorithm&amp;gt; 里封装的，能对各种东西搜索，返回类型是 iterator，没搜到时返回 end() 迭代器
1. string 中的 find 现有一个 string s 搜索目标为 &amp;quot;abc&amp;quot;
find(string&amp;amp; str, pos = 0) 用法：s.find(&amp;quot;abc&amp;quot;)
Finds the first substring equal to the given character sequence. Search begins at pos, i.e. the found substring must not begin in a position preceding pos.
找到搜索目标第一次出现的位置，即第一个 &amp;quot;abc&amp;quot; 出现的位置
如果搜索目标为空，空字符串第一次出现的位置为字符串开头，即 s.find(t) 会返回 0
find_first_of(string&amp;amp; str, pos = 0) 用法：s.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 处理输入</title>
      <link>https://wy-luke.github.io/posts/cpp-input/</link>
      <pubDate>Sun, 18 Sep 2022 17:18:10 +0800</pubDate>
      
      <guid>https://wy-luke.github.io/posts/cpp-input/</guid>
      <description>1. 输入一个数 int a; cin &amp;gt;&amp;gt; a; 2. 连续输入一个数 int a; while (cin &amp;gt;&amp;gt; a) { } 3. 按行读取 每次读取一行输入，包含空格，已回车换行结束
string input; while (getline(cin, input)) { } 4. 按行读取后，提取每行的字符串 字符串之间用空格间隔 string input; while (getline(cin, input)) { istringstream iss(input); string str; // &amp;#34;&amp;gt;&amp;gt;&amp;#34;会忽视字符串之间所有的回车和空格，即每次读取一个有效字符串输入 // 在这里 iss 是每行的输入，不包含回车，所以 &amp;#34;&amp;gt;&amp;gt;&amp;#34; 会忽视掉字符串中间的所有空格 while(iss &amp;gt;&amp;gt; str) { } } 字符串之间用逗号（或其他任意字符）间隔 string input; while (getline(cin, input)) { istringstream iss(input); string str; // 提取分隔符之间的字符串，注意这里提取出的可以是空字符串 // 若 &amp;#34;a,,b&amp;#34; 则提取出 a b 和一个空字符串 // 同时，若以间隔符结尾，则不会再记入一个空字符串 // 若 &amp;#34;,,&amp;#34; 则提取出 2 个空字符串 while(getline(iss, str, &amp;#39;,&amp;#39;)) { } } </description>
    </item>
    
    <item>
      <title>深挖数字的二进制表示与运算溢出</title>
      <link>https://wy-luke.github.io/posts/numbers/</link>
      <pubDate>Tue, 30 Aug 2022 20:01:50 +0800</pubDate>
      
      <guid>https://wy-luke.github.io/posts/numbers/</guid>
      <description>基本概念 首先说明一下三个名词：
原码：一个整数，按照绝对值大小转换成的二进制数，称为原码。
反码：将二进制数按位取反，所得的新二进制数称为原二进制数的反码。
补码：反码加 1 称为补码。
在计算机中，数字是以二进制形式储存的，如一个 int 为 4 字节，32 位，即可以 32 位二进制数表示
数字又分为有符号（signed）和无符号（unsigned），即正负
对于有符号类型，由第一位二进制数表示正负，0 表示正，1 表示负
所以一个正数，其存储形式就是第一位 1 加上该正数的二进制
而负数则是以其正值的补码形式表示（第一位 0 在这个过程就变成了 1）
而对于无符号类型，不再使用第一位表示符号，所有位均用于存储数据，所以无符号类型比有符号类型的数值上限大两倍左右
INT_MAN = (2^31)-1, UINT_MAX = (2^32)-1
-1 是因为 0 的存在
计算过程的溢出 无符号在溢出时，自动根据其位数取模
对此 C/C++ 的规范是有定义的，“溢出后的数会以2^(8*sizeof(type))作模运算”，也就是说，如果一个 unsigned char（1 字符，8 bits）溢出了，会把溢出的值与 2^8=256 取模，int 溢出则是与 2^32 取模
对于 signed 整型的溢出，C/C++ 的规范定义是“undefined behavior”，虽然没有定义，各编译器可自己实现，但是大部分的溢出机制都是一样的
有符号整型溢出又可分为向上溢出和向下溢出。假设用 k 个字节表示一个整型变量, 那么这个变量可以表示的有符号整数的范围是-2^(8k-1) ~ 2^(8k-1) – 1,那么两个正整数或者两个负整数相加就有可能超过这个整型变量所能表示的范围, 向上超出&amp;gt;2^(8k-1) – 1我们称之为向上溢出, 向下超出&amp;lt;-2^(8k-1), 我们称之为向下溢出
对于signed char,正整数最大值为127，负整数最小值为128。unsigned char所能表示的最大值为255</description>
    </item>
    
    <item>
      <title>C&#43;&#43; STL 二分 lower_bound / upper_bound 用法详解</title>
      <link>https://wy-luke.github.io/posts/binary-search/</link>
      <pubDate>Wed, 25 May 2022 14:44:19 +0800</pubDate>
      
      <guid>https://wy-luke.github.io/posts/binary-search/</guid>
      <description>假设我们要在一个 vector&amp;lt;int&amp;gt; 中，查找一个数 value
语法 auto p = std::lower_bound(v.begin(), v.end(), value) auto p = std::upper_bound(v.begin(), v.end(), value) 返回的值类型是 iterator 即迭代器，理解为指针即可
定义 lower_bound 获取第一个大于等于value的指针
is not less than
upper_bound 获取第一个大于 value的指针
is greater than value
用法详解 由上可以引申出多种用法：
要查找的每个数都存在时，如果这个数只存在一次 lower_bound 和 upper_bound - 1 结果一样，同样指向该数，upper_bound 指向第一个大于value的数
要查找的每个数都存在时，如果这个数存在多次 lower_bound 能查找到左侧边界，upper_bound - 1 能查找到右侧边界
要查找的数不在时 lower_bound 和 upper_bound 结果一样，同样指向第一个大于value的数
引申 STL 里面还有一个 equal_range()，就是返回一个pair，分别为 lower_bound 和 upper_bound 的结果
可以理解为一个左闭右开 [start, end) ，区间为要查找的 vector 里面，等于 value 的部分</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 自定义排序顺序详解，优先级队列 &#43; lambda 表达式</title>
      <link>https://wy-luke.github.io/posts/custom-sort/</link>
      <pubDate>Sun, 27 Mar 2022 21:41:03 +0800</pubDate>
      
      <guid>https://wy-luke.github.io/posts/custom-sort/</guid>
      <description>1. C++ named requirements ( 具名要求 ) : Compare C++ 中没有 Comparator 类，Campare 是一个 requirement ，可以理解为一种定义，要求。
yields true if the first argument of the call appears before the second in the strict weak ordering relation induced by this type, and false otherwise.
人话来讲，比较两个参数，返回 bool 值，当返回 true 时，第一个参数排在第二个参数前面，即第一个参数先进入 Container（如 vector ）
注意这里只关心返回 true 时的情况， 当两个参数相等（即无排序要求）和第一个参数在后面、第二个参数在前面时，都返回 false，在自定义 Campare 时需要注意这一点！！！
也就是说，在自定义 Campare 时，当第一个参数排在第二个参数前面时，返回 true ，其他情况均返回false
所以，在排序时，如果要保持相等元素的相对位置，即稳定排序，要用stable_sort()
否则，用sort()即可（不能保证相等元素相对位置不变）
2. std::greater std::less std::greater : 当第一个参数大于第二个参数时，返回 true</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 生成指定范围随机数的方法总结</title>
      <link>https://wy-luke.github.io/posts/cpp-random/</link>
      <pubDate>Sun, 27 Mar 2022 15:51:03 +0800</pubDate>
      
      <guid>https://wy-luke.github.io/posts/cpp-random/</guid>
      <description>1. rand() rand() % max 可以生成 [0, max) 范围的随机数，则
// 生成 [0, max] int x = rand() % (max + 1); // 生成 [1, max + 1) ，即 [1, max] int x = 1 + rand() % (max); // 生成 [min, max] 范围的随机数 int x = min + rand() % (max - min + 1); 2. STL 以下套用即可，具体解释见 cppreference
std::random_device rd; //Will be used to obtain a seed for the random number engine std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd() std::uniform_int_distribution&amp;lt;&amp;gt; distrib(1, 6); // 指定范围 // Use `distrib` to transform the random unsigned int generated by gen into an int in [1, 6] // 生成 [1, 6] 范围的随机数 std::cout &amp;lt;&amp;lt; distrib(gen) &amp;lt;&amp;lt; endl; </description>
    </item>
    
  </channel>
</rss>
