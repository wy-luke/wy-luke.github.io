[{"content":"1. 输入一个数 int a; cin \u0026gt;\u0026gt; a; 2. 连续输入一个数 int a; while (cin \u0026gt;\u0026gt; a) { } 3. 按行读取 每次读取一行输入，包含空格，已回车换行结束\nstring input; while (getline(cin, input)) { } 4. 按行读取后，提取每行的字符串 字符串之间用空格间隔 string input; while (getline(cin, input)) { istringstream iss(input); string str; // \u0026#34;\u0026gt;\u0026gt;\u0026#34;会忽视字符串之间所有的回车和空格，即每次读取一个有效字符串输入 // 在这里 iss 是每行的输入，不包含回车，所以 \u0026#34;\u0026gt;\u0026gt;\u0026#34; 会忽视掉字符串中间的所有空格 while(iss \u0026gt;\u0026gt; str) { } } 字符串之间用逗号（或其他任意字符）间隔 string input; while (getline(cin, input)) { istringstream iss(input); string str; // 提取分隔符之间的字符串，注意这里提取出的可以是空字符串 // 若 \u0026#34;a,,b\u0026#34; 则提取出 a b 和一个空字符串 // 同时，若以间隔符结尾，则不会再记入一个空字符串 // 若 \u0026#34;,,\u0026#34; 则提取出 2 个空字符串 while(getline(iss, str, \u0026#39;,\u0026#39;)) { } } ","permalink":"https://wy-luke.github.io/posts/cpp-input/","summary":"1. 输入一个数 int a; cin \u0026gt;\u0026gt; a; 2. 连续输入一个数 int a; while (cin \u0026gt;\u0026gt; a) { } 3. 按行读取 每次读取一行输入，包含空格，已回车换行结束\nstring input; while (getline(cin, input)) { } 4. 按行读取后，提取每行的字符串 字符串之间用空格间隔 string input; while (getline(cin, input)) { istringstream iss(input); string str; // \u0026#34;\u0026gt;\u0026gt;\u0026#34;会忽视字符串之间所有的回车和空格，即每次读取一个有效字符串输入 // 在这里 iss 是每行的输入，不包含回车，所以 \u0026#34;\u0026gt;\u0026gt;\u0026#34; 会忽视掉字符串中间的所有空格 while(iss \u0026gt;\u0026gt; str) { } } 字符串之间用逗号（或其他任意字符）间隔 string input; while (getline(cin, input)) { istringstream iss(input); string str; // 提取分隔符之间的字符串，注意这里提取出的可以是空字符串 // 若 \u0026#34;a,,b\u0026#34; 则提取出 a b 和一个空字符串 // 同时，若以间隔符结尾，则不会再记入一个空字符串 // 若 \u0026#34;,,\u0026#34; 则提取出 2 个空字符串 while(getline(iss, str, \u0026#39;,\u0026#39;)) { } } ","title":"C++ 处理输入"},{"content":"基本概念 首先说明一下三个名词：\n原码：一个整数，按照绝对值大小转换成的二进制数，称为原码。\n反码：将二进制数按位取反，所得的新二进制数称为原二进制数的反码。\n补码：反码加 1 称为补码。\n在计算机中，数字是以二进制形式储存的，如一个 int 为 4 字节，32 位，即可以 32 位二进制数表示\n数字又分为有符号（signed）和无符号（unsigned），即正负\n对于有符号类型，由第一位二进制数表示正负，0 表示正，1 表示负\n所以一个正数，其存储形式就是第一位 1 加上该正数的二进制\n而负数则是以其正值的补码形式表示（第一位 0 在这个过程就变成了 1）\n而对于无符号类型，不再使用第一位表示符号，所有位均用于存储数据，所以无符号类型比有符号类型的数值上限大两倍左右\nINT_MAN = (2^31)-1, UINT_MAX = (2^32)-1\n-1 是因为 0 的存在\n计算过程的溢出 无符号在溢出时，自动根据其位数取模\n对此 C/C++ 的规范是有定义的，“溢出后的数会以2^(8*sizeof(type))作模运算”，也就是说，如果一个 unsigned char（1 字符，8 bits）溢出了，会把溢出的值与 2^8=256 取模，int 溢出则是与 2^32 取模\n对于 signed 整型的溢出，C/C++ 的规范定义是“undefined behavior”，虽然没有定义，各编译器可自己实现，但是大部分的溢出机制都是一样的\n有符号整型溢出又可分为向上溢出和向下溢出。假设用 k 个字节表示一个整型变量, 那么这个变量可以表示的有符号整数的范围是-2^(8k-1) ~ 2^(8k-1) – 1,那么两个正整数或者两个负整数相加就有可能超过这个整型变量所能表示的范围, 向上超出\u0026gt;2^(8k-1) – 1我们称之为向上溢出, 向下超出\u0026lt;-2^(8k-1), 我们称之为向下溢出\n对于signed char,正整数最大值为127，负整数最小值为128。unsigned char所能表示的最大值为255\nsigned char x; x = 125 + 5; 上面代码会输出：-126，因为130的二进制位为10000010，符号为1，表示负数。对于有符号整型，负数是用补码表示的，即绝对值取反后加一。根据之前方法逆向回去，先减一后再取反得01111110，即126.所以10000010表示的是-126\nsigned char x; x = (-100) + (-100); 上面代码会输出56，因为200的二进制为11001000，-200根据补码的算法，得出00111000即56\n上面的两个例子无论是向上溢出还是向下溢出，绝对值都在相对于无符号整型能表示的范围内。对于signed char如果结果为400，超出了位数表示范围，取结果的低八位\nsigned char x; x = 200 + 200; 因此上面代码会输出-112。如果x的结果为负数且超出了255，则取结果的低八位，并进行补码的反向操作，减一后取反\n参考：\nhttps://en.wikipedia.org/wiki/Integer_overflow\nhttps://zhuanlan.zhihu.com/p/28563004\n","permalink":"https://wy-luke.github.io/posts/numbers/","summary":"基本概念 首先说明一下三个名词：\n原码：一个整数，按照绝对值大小转换成的二进制数，称为原码。\n反码：将二进制数按位取反，所得的新二进制数称为原二进制数的反码。\n补码：反码加 1 称为补码。\n在计算机中，数字是以二进制形式储存的，如一个 int 为 4 字节，32 位，即可以 32 位二进制数表示\n数字又分为有符号（signed）和无符号（unsigned），即正负\n对于有符号类型，由第一位二进制数表示正负，0 表示正，1 表示负\n所以一个正数，其存储形式就是第一位 1 加上该正数的二进制\n而负数则是以其正值的补码形式表示（第一位 0 在这个过程就变成了 1）\n而对于无符号类型，不再使用第一位表示符号，所有位均用于存储数据，所以无符号类型比有符号类型的数值上限大两倍左右\nINT_MAN = (2^31)-1, UINT_MAX = (2^32)-1\n-1 是因为 0 的存在\n计算过程的溢出 无符号在溢出时，自动根据其位数取模\n对此 C/C++ 的规范是有定义的，“溢出后的数会以2^(8*sizeof(type))作模运算”，也就是说，如果一个 unsigned char（1 字符，8 bits）溢出了，会把溢出的值与 2^8=256 取模，int 溢出则是与 2^32 取模\n对于 signed 整型的溢出，C/C++ 的规范定义是“undefined behavior”，虽然没有定义，各编译器可自己实现，但是大部分的溢出机制都是一样的\n有符号整型溢出又可分为向上溢出和向下溢出。假设用 k 个字节表示一个整型变量, 那么这个变量可以表示的有符号整数的范围是-2^(8k-1) ~ 2^(8k-1) – 1,那么两个正整数或者两个负整数相加就有可能超过这个整型变量所能表示的范围, 向上超出\u0026gt;2^(8k-1) – 1我们称之为向上溢出, 向下超出\u0026lt;-2^(8k-1), 我们称之为向下溢出\n对于signed char,正整数最大值为127，负整数最小值为128。unsigned char所能表示的最大值为255","title":"深挖数字的二进制表示与运算溢出"},{"content":"数据分为基本数据类型和引用数据类型\n众所周知，（一般）变量是存在栈中的\n基本数据类型的变量：数据直接存储在栈中 引用数据类型的变量：栈中存储的是一个指针，指向堆中的一块内存，真实的数据存放在堆内存里\n对于一般拷贝操作而言，就是把栈中的数据拷贝一份，内容和原来一样\n基本类型 所以，对于基本类型，由于数据直接存储在栈中，拷贝一份就意味着把数据拷贝了一份\n比如int x = 4，那么栈中就有一块内存储存了4，int y = x就是在栈中新建一个变量(一块内存)，并拷贝源数据，即4，\n所以此时栈中有两块内存储存的都是4，一个是x一个是y，更改x的值不会影响y，反之同样\n所以基本类型默认就是深拷贝\n那么，对于基本类型，怎么实现浅拷贝呢？C++在某种意义上实现可以通过指针或引用实现，而Java没有指针，所以并不太好实现，可以参考这里\n引用类型 对于引用类型就不太一样了，int[] x = new int[] {1,2}时，在栈中有一个变量x，指向堆内存中的数组\nint[] y = x时，复制栈中的数据，也就是说，在栈中新建了一个指针y，和x指向同一块堆内存，也就是刚才的数组\n所以此时栈中有两块内存储存的都是指针，一个是x一个是y，但是指向同一块堆内存，更改x的值，如x[1] = 2，y的值也会发生改变\n这就是浅拷贝，所以java引用类型默认是浅拷贝\n而深拷贝是要在栈中新建一个变量的同时，并且在堆中也新建一块内存，把要复制的值存进去，并将在栈中新建的变量指向堆中新建的内存\n即： 浅拷贝：在栈中新建一个变量，还是指向同一块内存 深拷贝：在栈中新建一个变量，并且在堆中也新建一块内存，把要复制的值存进去，将在栈中新建的变量指向堆中新建的内存\n那么，既然用=复制是浅拷贝，怎样能够实现深拷贝呢？\n对于数组，当然可以通过.clone()\nint[] src = ... int[] dest = src.clone(); 对于class，一种比较安全的方法是先序列化，然后反序列号，可以参考这里\n特殊的 String 类型 Java中的String类型比较特殊，虽然他是引用类型，但是他具有不可变性，也就是说，在堆内存中的一块String，如\u0026quot;hello\u0026quot;，内容是不能更改的\nstring x = \u0026quot;hello\u0026quot;后，再改变x的值：x=\u0026quot;world\u0026quot;，会在堆内存中重新划一块内存，储存\u0026quot;world\u0026quot;，并将x指向新内存，原有内存后续如果没有被引用就会被清理掉（垃圾回收）\n然而，若我们string x = \u0026quot;hello后string y = x，y和x指向同一块堆内存\u0026quot;hello\u0026quot;，但是如上一段所说，x=\u0026quot;world\u0026quot;会在堆中新建一块内存，而不是更改原有内存的数据，也就是说，现在，x指向world，而y依然指向hello\n所以对String虽然是引用类型，但是直接使用=等号，是深拷贝\n更详细的证明见这里\n","permalink":"https://wy-luke.github.io/posts/deep-shallow-copy/","summary":"数据分为基本数据类型和引用数据类型\n众所周知，（一般）变量是存在栈中的\n基本数据类型的变量：数据直接存储在栈中 引用数据类型的变量：栈中存储的是一个指针，指向堆中的一块内存，真实的数据存放在堆内存里\n对于一般拷贝操作而言，就是把栈中的数据拷贝一份，内容和原来一样\n基本类型 所以，对于基本类型，由于数据直接存储在栈中，拷贝一份就意味着把数据拷贝了一份\n比如int x = 4，那么栈中就有一块内存储存了4，int y = x就是在栈中新建一个变量(一块内存)，并拷贝源数据，即4，\n所以此时栈中有两块内存储存的都是4，一个是x一个是y，更改x的值不会影响y，反之同样\n所以基本类型默认就是深拷贝\n那么，对于基本类型，怎么实现浅拷贝呢？C++在某种意义上实现可以通过指针或引用实现，而Java没有指针，所以并不太好实现，可以参考这里\n引用类型 对于引用类型就不太一样了，int[] x = new int[] {1,2}时，在栈中有一个变量x，指向堆内存中的数组\nint[] y = x时，复制栈中的数据，也就是说，在栈中新建了一个指针y，和x指向同一块堆内存，也就是刚才的数组\n所以此时栈中有两块内存储存的都是指针，一个是x一个是y，但是指向同一块堆内存，更改x的值，如x[1] = 2，y的值也会发生改变\n这就是浅拷贝，所以java引用类型默认是浅拷贝\n而深拷贝是要在栈中新建一个变量的同时，并且在堆中也新建一块内存，把要复制的值存进去，并将在栈中新建的变量指向堆中新建的内存\n即： 浅拷贝：在栈中新建一个变量，还是指向同一块内存 深拷贝：在栈中新建一个变量，并且在堆中也新建一块内存，把要复制的值存进去，将在栈中新建的变量指向堆中新建的内存\n那么，既然用=复制是浅拷贝，怎样能够实现深拷贝呢？\n对于数组，当然可以通过.clone()\nint[] src = ... int[] dest = src.clone(); 对于class，一种比较安全的方法是先序列化，然后反序列号，可以参考这里\n特殊的 String 类型 Java中的String类型比较特殊，虽然他是引用类型，但是他具有不可变性，也就是说，在堆内存中的一块String，如\u0026quot;hello\u0026quot;，内容是不能更改的\nstring x = \u0026quot;hello\u0026quot;后，再改变x的值：x=\u0026quot;world\u0026quot;，会在堆内存中重新划一块内存，储存\u0026quot;world\u0026quot;，并将x指向新内存，原有内存后续如果没有被引用就会被清理掉（垃圾回收）\n然而，若我们string x = \u0026quot;hello后string y = x，y和x指向同一块堆内存\u0026quot;hello\u0026quot;，但是如上一段所说，x=\u0026quot;world\u0026quot;会在堆中新建一块内存，而不是更改原有内存的数据，也就是说，现在，x指向world，而y依然指向hello\n所以对String虽然是引用类型，但是直接使用=等号，是深拷贝\n更详细的证明见这里","title":"Java 中基本类型与引用类型的深拷贝和浅拷贝"},{"content":"假设我们要在一个 vector\u0026lt;int\u0026gt; 中，查找一个数 value\n语法 auto p = std::lower_bound(v.begin(), v.end(), value) auto p = std::upper_bound(v.begin(), v.end(), value) 返回的值类型是 iterator 即迭代器，理解为指针即可\n定义 lower_bound 获取第一个大于等于value的指针\nis not less than\nupper_bound 获取第一个大于 value的指针\nis greater than value\n用法详解 由上可以引申出多种用法：\n要查找的每个数都存在时，如果这个数只存在一次 lower_bound 和 upper_bound - 1 结果一样，同样指向该数，upper_bound 指向第一个大于value的数\n要查找的每个数都存在时，如果这个数存在多次 lower_bound 能查找到左侧边界，upper_bound - 1 能查找到右侧边界\n要查找的数不在时 lower_bound 和 upper_bound 结果一样，同样指向第一个大于value的数\n引申 STL 里面还有一个 equal_range()，就是返回一个pair，分别为 lower_bound 和 upper_bound 的结果\n可以理解为一个左闭右开 [start, end) ，区间为要查找的 vector 里面，等于 value 的部分\n为什么呢，因为 lower_bound 找到第一个等于（如果存在） value 的，upper_bound 找到第一个大于 value 的，所以中间的部分，自然就是等于 value 的部分\n手写二分 若左闭右开区间，则 while (l \u0026lt; r)\n若左闭右闭区间，则 while (l \u0026lt;= r)\n全部 return left\n当寻找 lower_bound 时，向左侧靠拢，left 即为 lower_bound，即第一个大于 val 的\n当寻找 upperr_bound 时，向右侧靠拢，left 即为 upper_bound，即第一个大于 val 的\n","permalink":"https://wy-luke.github.io/posts/binary-search/","summary":"假设我们要在一个 vector\u0026lt;int\u0026gt; 中，查找一个数 value\n语法 auto p = std::lower_bound(v.begin(), v.end(), value) auto p = std::upper_bound(v.begin(), v.end(), value) 返回的值类型是 iterator 即迭代器，理解为指针即可\n定义 lower_bound 获取第一个大于等于value的指针\nis not less than\nupper_bound 获取第一个大于 value的指针\nis greater than value\n用法详解 由上可以引申出多种用法：\n要查找的每个数都存在时，如果这个数只存在一次 lower_bound 和 upper_bound - 1 结果一样，同样指向该数，upper_bound 指向第一个大于value的数\n要查找的每个数都存在时，如果这个数存在多次 lower_bound 能查找到左侧边界，upper_bound - 1 能查找到右侧边界\n要查找的数不在时 lower_bound 和 upper_bound 结果一样，同样指向第一个大于value的数\n引申 STL 里面还有一个 equal_range()，就是返回一个pair，分别为 lower_bound 和 upper_bound 的结果\n可以理解为一个左闭右开 [start, end) ，区间为要查找的 vector 里面，等于 value 的部分","title":"C++ STL 二分 lower_bound / upper_bound 用法详解"},{"content":"一个 int 占 4 字节（Byte），也就是 32 位（Bit），其中第一位用来存储正负号，1 表示负数，0 表示正数\n也就是说，共有 31 位用来存储数据，所以，能够存储数字的总个数为 2^31=2147483648 （10^9）\n而在某种程度上，可以理解为，在存储上，0 被归为了正数\n所以正数最大值为 2^31-1，而负数最小值就是2^31\n更形象的解释看下面：\nInt32.MaxValue = 2^31 - 1 = 01111111111111111111111111111111 1 = 00000000000000000000000000000001 0 = 00000000000000000000000000000000 -1 = 11111111111111111111111111111111 Int32.MinValue = -2^31 = 10000000000000000000000000000000 可以明显的看出，为什么 int 类型最大值为 2^31-1，而最小值是2^31\n","permalink":"https://wy-luke.github.io/posts/int-range/","summary":"一个 int 占 4 字节（Byte），也就是 32 位（Bit），其中第一位用来存储正负号，1 表示负数，0 表示正数\n也就是说，共有 31 位用来存储数据，所以，能够存储数字的总个数为 2^31=2147483648 （10^9）\n而在某种程度上，可以理解为，在存储上，0 被归为了正数\n所以正数最大值为 2^31-1，而负数最小值就是2^31\n更形象的解释看下面：\nInt32.MaxValue = 2^31 - 1 = 01111111111111111111111111111111 1 = 00000000000000000000000000000001 0 = 00000000000000000000000000000000 -1 = 11111111111111111111111111111111 Int32.MinValue = -2^31 = 10000000000000000000000000000000 可以明显的看出，为什么 int 类型最大值为 2^31-1，而最小值是2^31","title":"为什么 int 类型最大值为 2^31-1，最小值为 -2^31"},{"content":"由于WPF执行的方式有些奇怪，并不是一般意义上的 “类\u0026ndash;实例化”\n所以如果你想要在其他 Class 文件、或其他窗口中，执行 MainWindow 中的一些函数时；或者是想要获取 MainWindow 的某个控件，并对其操作时（比如你要在一个新的窗口中，改变 MainWindow 的一个 Switch 的开关状态），就非常麻烦\n你可以把需要使用的函数定义为 静态（Static），但是这样带来的限制非常多，而且这种方法不适用与获取控件\n经查阅，只需一行代码：\nvar _mainWindow = Application.Current.Windows .Cast\u0026lt;Window\u0026gt;() .FirstOrDefault(window =\u0026gt; window is MainWindow) as MainWindow; Application.Current contains a collection of all windows in your application, you can get the other window with a query such as\n然后就可以对 MainWindow 中的任何函数或控件进行操作了，如：\n_mainWindow.Switch1.IsOn = false; 此时函数也无需定义为 静态（Static）了，非常方便。\n同理也适用于获取其他窗口，只需要将上面代码的 MainWindow 改为你需要寻找的窗口名即可\n参考链接: https://stackoverflow.com/questions/13644114/how-can-i-access-a-control-in-wpf-from-another-class-or-window/44988191#44988191\n","permalink":"https://wy-luke.github.io/posts/wpf-get-mainwindow/","summary":"由于WPF执行的方式有些奇怪，并不是一般意义上的 “类\u0026ndash;实例化”\n所以如果你想要在其他 Class 文件、或其他窗口中，执行 MainWindow 中的一些函数时；或者是想要获取 MainWindow 的某个控件，并对其操作时（比如你要在一个新的窗口中，改变 MainWindow 的一个 Switch 的开关状态），就非常麻烦\n你可以把需要使用的函数定义为 静态（Static），但是这样带来的限制非常多，而且这种方法不适用与获取控件\n经查阅，只需一行代码：\nvar _mainWindow = Application.Current.Windows .Cast\u0026lt;Window\u0026gt;() .FirstOrDefault(window =\u0026gt; window is MainWindow) as MainWindow; Application.Current contains a collection of all windows in your application, you can get the other window with a query such as\n然后就可以对 MainWindow 中的任何函数或控件进行操作了，如：\n_mainWindow.Switch1.IsOn = false; 此时函数也无需定义为 静态（Static）了，非常方便。\n同理也适用于获取其他窗口，只需要将上面代码的 MainWindow 改为你需要寻找的窗口名即可\n参考链接: https://stackoverflow.com/questions/13644114/how-can-i-access-a-control-in-wpf-from-another-class-or-window/44988191#44988191","title":"WPF 获取主窗口 MainWindow 实例，以及其中的控件"},{"content":"1. C++ named requirements ( 具名要求 ) : Compare C++ 中没有 Comparator 类，Campare 是一个 requirement ，可以理解为一种定义，要求。\nyields true if the first argument of the call appears before the second in the strict weak ordering relation induced by this type, and false otherwise.\n人话来讲，比较两个参数，返回 bool 值，当返回 true 时，第一个参数排在第二个参数前面，即第一个参数先进入 Container（如 vector ）\n注意这里只关心返回 true 时的情况， 当两个参数相等（即无排序要求）和第一个参数在后面、第二个参数在前面时，都返回 false，在自定义 Campare 时需要注意这一点！！！\n也就是说，在自定义 Campare 时，当第一个参数排在第二个参数前面时，返回 true ，其他情况均返回false\n所以，在排序时，如果要保持相等元素的相对位置，即稳定排序，要用stable_sort()\n否则，用sort()即可（不能保证相等元素相对位置不变）\n2. std::greater std::less std::greater : 当第一个参数大于第二个参数时，返回 true\nFor T which is not a pointer type, true if lhs \u0026gt; rhs, false otherwise（包括等于时）. （ lhs 为第一个参数，rhs 为第二个参数）\nstd::less 反之\n3. 排序 对于 vector 排序时，若使用 std::greater，返回 true 时，第一个参数大于第二个参数，即较大的数排在前面，先进入 vector ，所以排序结果是降序\nvector\u0026lt;int\u0026gt; v{ 1, 5, 8, 9, 6, 7, 3, 4, 2, 0 }; // sort 默认为升序，即使用 less\u0026lt;int\u0026gt;() 作为参数 sort(v.begin(), v.end(), greater\u0026lt;int\u0026gt;()); 对于优先级队列，若使用 std::greater：当第一个参数大于第二个参数时，返回 true，即较大的数排在前面，先进入优先级队列 ，但是 优先级队列 为 先进入的后输出\n理解：优先级队列想象为堆，先进入的在下面，后进入的在上面，遍历时使用 top()\n所以，排序的结果是较大的数在下面，较小的数在上面，即小顶堆\n4. 使用 lambda 表达式自定义顺序 当容器里面不是 int 类型时，就不能直接使用 greater 进行排序\n此时可以使用 lambda 表达式，方便地自定义顺序，如：\n// lambda 表达式作为 Campare，当返回 true 时，left 先进入，后输出，即在优先级队列（堆）的下方 auto cmp = [](pair\u0026lt;int, int\u0026gt; left, pair\u0026lt;int, int\u0026gt; right) -\u0026gt; bool { return left.second \u0026lt; right.second; }; priority_queue\u0026lt;pair\u0026lt;int, int\u0026gt;, vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt;, decltype(cmp)\u0026gt; pq(cmp); 优先级队列里面存放的是 pair，我们定义，当 left.second \u0026lt; right.second 时，返回 true，即 second 值较小的排在优先级队列的下方，可以理解为大顶堆\n","permalink":"https://wy-luke.github.io/posts/custom-sort/","summary":"1. C++ named requirements ( 具名要求 ) : Compare C++ 中没有 Comparator 类，Campare 是一个 requirement ，可以理解为一种定义，要求。\nyields true if the first argument of the call appears before the second in the strict weak ordering relation induced by this type, and false otherwise.\n人话来讲，比较两个参数，返回 bool 值，当返回 true 时，第一个参数排在第二个参数前面，即第一个参数先进入 Container（如 vector ）\n注意这里只关心返回 true 时的情况， 当两个参数相等（即无排序要求）和第一个参数在后面、第二个参数在前面时，都返回 false，在自定义 Campare 时需要注意这一点！！！\n也就是说，在自定义 Campare 时，当第一个参数排在第二个参数前面时，返回 true ，其他情况均返回false\n所以，在排序时，如果要保持相等元素的相对位置，即稳定排序，要用stable_sort()\n否则，用sort()即可（不能保证相等元素相对位置不变）\n2. std::greater std::less std::greater : 当第一个参数大于第二个参数时，返回 true","title":"C++ 自定义排序顺序详解，优先级队列 + lambda 表达式"},{"content":"1. rand() rand() % max 可以生成 [0, max) 范围的随机数，则\n// 生成 [0, max] int x = rand() % (max + 1); // 生成 [1, max + 1) ，即 [1, max] int x = 1 + rand() % (max); // 生成 [min, max] 范围的随机数 int x = min + rand() % (max - min + 1); 2. STL 以下套用即可，具体解释见 cppreference\nstd::random_device rd; //Will be used to obtain a seed for the random number engine std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd() std::uniform_int_distribution\u0026lt;\u0026gt; distrib(1, 6); // 指定范围 // Use `distrib` to transform the random unsigned int generated by gen into an int in [1, 6] // 生成 [1, 6] 范围的随机数 std::cout \u0026lt;\u0026lt; distrib(gen) \u0026lt;\u0026lt; endl; ","permalink":"https://wy-luke.github.io/posts/cpp-random/","summary":"1. rand() rand() % max 可以生成 [0, max) 范围的随机数，则\n// 生成 [0, max] int x = rand() % (max + 1); // 生成 [1, max + 1) ，即 [1, max] int x = 1 + rand() % (max); // 生成 [min, max] 范围的随机数 int x = min + rand() % (max - min + 1); 2. STL 以下套用即可，具体解释见 cppreference\nstd::random_device rd; //Will be used to obtain a seed for the random number engine std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd() std::uniform_int_distribution\u0026lt;\u0026gt; distrib(1, 6); // 指定范围 // Use `distrib` to transform the random unsigned int generated by gen into an int in [1, 6] // 生成 [1, 6] 范围的随机数 std::cout \u0026lt;\u0026lt; distrib(gen) \u0026lt;\u0026lt; endl; ","title":"C++ 生成指定范围随机数的方法总结"},{"content":"针对稍简单的操作，一行代码即可搞定\nstring text = \u0026#34;abcabc\u0026#34;; // Regex.Replace 的第一个参数为要处理的字符串，第二个为正则表达式，第三个为你的操作 // 匹配字符串中所有的 a，然后转为大写。m.Value 即为匹配到的字符 text = Regex.Replace(text, \u0026#34;[a]\u0026#34;, m =\u0026gt; m.Value.ToUpper()); Console.WriteLine(text); \u0026gt;\u0026gt;\u0026gt;\u0026#34;AbcAbc\u0026#34; 针对更复杂的操作，可以专门写一个函数\nprivate static string ReplaceMethod(Match m) { // m.ToString() 即为匹配到的字符，可做任意处理 return m.ToString().ToUpper(); } private static void Main() { var text = \u0026#34;abcabc\u0026#34;; var myEvaluator = new MatchEvaluator(ReplaceMethod); text = Regex.Replace(text, \u0026#34;[a]\u0026#34;, myEvaluator); Console.WriteLine(text); } \u0026gt;\u0026gt;\u0026gt;\u0026#34;AbcAbc\u0026#34; ","permalink":"https://wy-luke.github.io/posts/cs-pick-custom-char/","summary":"针对稍简单的操作，一行代码即可搞定\nstring text = \u0026#34;abcabc\u0026#34;; // Regex.Replace 的第一个参数为要处理的字符串，第二个为正则表达式，第三个为你的操作 // 匹配字符串中所有的 a，然后转为大写。m.Value 即为匹配到的字符 text = Regex.Replace(text, \u0026#34;[a]\u0026#34;, m =\u0026gt; m.Value.ToUpper()); Console.WriteLine(text); \u0026gt;\u0026gt;\u0026gt;\u0026#34;AbcAbc\u0026#34; 针对更复杂的操作，可以专门写一个函数\nprivate static string ReplaceMethod(Match m) { // m.ToString() 即为匹配到的字符，可做任意处理 return m.ToString().ToUpper(); } private static void Main() { var text = \u0026#34;abcabc\u0026#34;; var myEvaluator = new MatchEvaluator(ReplaceMethod); text = Regex.Replace(text, \u0026#34;[a]\u0026#34;, myEvaluator); Console.WriteLine(text); } \u0026gt;\u0026gt;\u0026gt;\u0026#34;AbcAbc\u0026#34; ","title":"C# 正则表达式匹配特定字符然后做任意处理，并保留字符位置"},{"content":"1. 基本用法 a[start:stop] # 从 index=start 开始（即包含start），到 index=stop-1（即不包含stop） a[start:] # 从 index=start 开始（包含 start ），到最后 a[:stop] # 从头开始，到 stop-1 a[:] # 取整个 List 注意：\n结束的 index （索引值） 是 stop-1 ，也就是说不包含 index=stop 的那个值 我这里说的 index 是索引值，从 0 开始，这个大家应该都知道 a[1:4] # 从 index=1 取到 index=4 a[1:] # 从 index=1 取到最后 a[n, start:stop] # 对一个二维 List，取第 n 行，从 index=start 到 index=stop-1 间的列 具体示例：\n\u0026gt;\u0026gt;\u0026gt; a = [1,2,3,4,5,6] \u0026gt;\u0026gt;\u0026gt; a[1:4] [2, 3, 4] \u0026gt;\u0026gt;\u0026gt; a[1:] [2, 3, 4, 5, 6] 2. 步长 step 除此之外，还有一个 step （步长）的东西：\na[start:stop:step] # 从 index=start 到 index=stop-1，每隔 step 取一个，不超过 stop-1 具体示例：\n\u0026gt;\u0026gt;\u0026gt; a = [1,2,3,4,5,6] \u0026gt;\u0026gt;\u0026gt; a[::2] # 注意这个双冒号就是省略了 start 和 stop，即从头取到尾，每隔 2 步取一个 [1,3,5] 注意：\nstep 默认为1 stop 和 start 的差就是截取片段的长度（当 step 是1时） 3. index 为负数时 start or stop 也可以为负数，就意味着从后往前数：\na[-1] # 取最后一个值 a[-2:] # 取最后两个值 a[:-2] # 取除最后两个值之外的所有值 具体示例：\n\u0026gt;\u0026gt;\u0026gt; a = [1,2,3,4,5,6] \u0026gt;\u0026gt;\u0026gt; a[-1] [1,3,5] 4. step 为负数时 同样的，step也可以取负数，当step为负数时，发生了一点小变化 step为负数代表从后往前取，这时start \u0026gt; stop，也就是说 start 是较后面的数，stop 为前面的数 和上面一样，start包含，stop不包含 具体示例：\n\u0026gt;\u0026gt;\u0026gt; a = [1,2,3,4,5,6] \u0026gt;\u0026gt;\u0026gt; a[3:1:-1] [4, 3] \u0026gt;\u0026gt;\u0026gt; a[1::-1] [2, 1] 好好理解一下\n5. 常见错误 当你截取的范围 完全 超过数组的长度时，你会得到一个空列表，而 Python 不会报错。 比如：当 a 仅包含 1 个元素，而你使用 a[5:] a[:-2] 时，你就会得到一个空列表，而不是报错信息，这点尤其需要注意。\n当你截取的范围 部分 超过数组的长度时，你会得到你截取到的部分，而 Python 不会报错。 比如：\n\u0026gt;\u0026gt;\u0026gt; a = [1] \u0026gt;\u0026gt;\u0026gt; a[:5] [1] \u0026gt;\u0026gt;\u0026gt; a[-5:] [1] 6. 记忆技巧 +---+---+---+---+---+---+ | P | y | t | h | o | n | +---+---+---+---+---+---+ 0 1 2 3 4 5 6 -6 -5 -4 -3 -2 -1 0 One way to remember how slices work is to think of the indices as pointing between characters, with the left edge of the first character numbered 0. Then the right edge of the last character of a string of n characters has index n.\n如上图所示，你把 start 和 stop 想象成是指向两个元素之间的，而不是指向元素。这样显然，start 和 stop 之间的元素，就是你截取的片段。\n","permalink":"https://wy-luke.github.io/posts/python-slice/","summary":"1. 基本用法 a[start:stop] # 从 index=start 开始（即包含start），到 index=stop-1（即不包含stop） a[start:] # 从 index=start 开始（包含 start ），到最后 a[:stop] # 从头开始，到 stop-1 a[:] # 取整个 List 注意：\n结束的 index （索引值） 是 stop-1 ，也就是说不包含 index=stop 的那个值 我这里说的 index 是索引值，从 0 开始，这个大家应该都知道 a[1:4] # 从 index=1 取到 index=4 a[1:] # 从 index=1 取到最后 a[n, start:stop] # 对一个二维 List，取第 n 行，从 index=start 到 index=stop-1 间的列 具体示例：\n\u0026gt;\u0026gt;\u0026gt; a = [1,2,3,4,5,6] \u0026gt;\u0026gt;\u0026gt; a[1:4] [2, 3, 4] \u0026gt;\u0026gt;\u0026gt; a[1:] [2, 3, 4, 5, 6] 2.","title":"Python中列表截取（Slice，即冒号 : ）的用法详解"}]