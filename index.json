[{"content":"数据分为基本数据类型和引用数据类型\n众所周知，（一般）变量是存在栈中的\n基本数据类型的变量：数据直接存储在栈中 引用数据类型的变量：栈中存储的是一个指针，指向堆中的一块内存，真实的数据存放在堆内存里\n对于一般拷贝操作而言，就是把栈中的数据拷贝一份，内容和原来一样\n基本类型 所以，对于基本类型，由于数据直接存储在栈中，拷贝一份就意味着把数据拷贝了一份\n比如int x = 4，那么栈中就有一块内存储存了4，int y = x就是在栈中新建一个变量(一块内存)，并拷贝源数据，即4，\n所以此时栈中有两块内存储存的都是4，一个是x一个是y，更改x的值不会影响y，反之同样\n所以基本类型默认就是深拷贝\n那么，对于基本类型，怎么实现浅拷贝呢？C++在某种意义上实现可以通过指针或引用实现，而Java没有指针，所以并不太好实现，可以参考这里\n引用类型 对于引用类型就不太一样了，int[] x = new int[] {1,2}时，在栈中有一个变量x，指向堆内存中的数组\nint[] y = x时，复制栈中的数据，也就是说，在栈中新建了一个指针y，和x指向同一块堆内存，也就是刚才的数组\n所以此时栈中有两块内存储存的都是指针，一个是x一个是y，但是指向同一块堆内存，更改x的值，如x[1] = 2，y的值也会发生改变\n这就是浅拷贝，所以java引用类型默认是浅拷贝\n而深拷贝是要在栈中新建一个变量的同时，并且在堆中也新建一块内存，把要复制的值存进去，并将在栈中新建的变量指向堆中新建的内存\n即： 浅拷贝：在栈中新建一个变量，还是指向同一块内存 深拷贝：在栈中新建一个变量，并且在堆中也新建一块内存，把要复制的值存进去，将在栈中新建的变量指向堆中新建的内存\n那么，既然用=复制是浅拷贝，怎样能够实现深拷贝呢？\n对于数组，当然可以通过.clone()\nint[] src = ... int[] dest = src.clone(); 对于class，一种比较安全的方法是先序列化，然后反序列号，可以参考这里\n特殊的 String 类型 Java中的String类型比较特殊，虽然他是引用类型，但是他具有不可变性，也就是说，在堆内存中的一块String，如\u0026quot;hello\u0026quot;，内容是不能更改的\nstring x = \u0026quot;hello\u0026quot;后，再改变x的值：x=\u0026quot;world\u0026quot;，会在堆内存中重新划一块内存，储存\u0026quot;world\u0026quot;，并将x指向新内存，原有内存后续如果没有被引用就会被清理掉（垃圾回收）\n然而，若我们string x = \u0026quot;hello后string y = x，y和x指向同一块堆内存\u0026quot;hello\u0026quot;，但是如上一段所说，x=\u0026quot;world\u0026quot;会在堆中新建一块内存，而不是更改原有内存的数据，也就是说，现在，x指向world，而y依然指向hello\n所以对String虽然是引用类型，但是直接使用=等号，是深拷贝\n更详细的证明见这里\n","permalink":"https://wy-luke.github.io/posts/deep-shallow-copy/","summary":"数据分为基本数据类型和引用数据类型\n众所周知，（一般）变量是存在栈中的\n基本数据类型的变量：数据直接存储在栈中 引用数据类型的变量：栈中存储的是一个指针，指向堆中的一块内存，真实的数据存放在堆内存里\n对于一般拷贝操作而言，就是把栈中的数据拷贝一份，内容和原来一样\n基本类型 所以，对于基本类型，由于数据直接存储在栈中，拷贝一份就意味着把数据拷贝了一份\n比如int x = 4，那么栈中就有一块内存储存了4，int y = x就是在栈中新建一个变量(一块内存)，并拷贝源数据，即4，\n所以此时栈中有两块内存储存的都是4，一个是x一个是y，更改x的值不会影响y，反之同样\n所以基本类型默认就是深拷贝\n那么，对于基本类型，怎么实现浅拷贝呢？C++在某种意义上实现可以通过指针或引用实现，而Java没有指针，所以并不太好实现，可以参考这里\n引用类型 对于引用类型就不太一样了，int[] x = new int[] {1,2}时，在栈中有一个变量x，指向堆内存中的数组\nint[] y = x时，复制栈中的数据，也就是说，在栈中新建了一个指针y，和x指向同一块堆内存，也就是刚才的数组\n所以此时栈中有两块内存储存的都是指针，一个是x一个是y，但是指向同一块堆内存，更改x的值，如x[1] = 2，y的值也会发生改变\n这就是浅拷贝，所以java引用类型默认是浅拷贝\n而深拷贝是要在栈中新建一个变量的同时，并且在堆中也新建一块内存，把要复制的值存进去，并将在栈中新建的变量指向堆中新建的内存\n即： 浅拷贝：在栈中新建一个变量，还是指向同一块内存 深拷贝：在栈中新建一个变量，并且在堆中也新建一块内存，把要复制的值存进去，将在栈中新建的变量指向堆中新建的内存\n那么，既然用=复制是浅拷贝，怎样能够实现深拷贝呢？\n对于数组，当然可以通过.clone()\nint[] src = ... int[] dest = src.clone(); 对于class，一种比较安全的方法是先序列化，然后反序列号，可以参考这里\n特殊的 String 类型 Java中的String类型比较特殊，虽然他是引用类型，但是他具有不可变性，也就是说，在堆内存中的一块String，如\u0026quot;hello\u0026quot;，内容是不能更改的\nstring x = \u0026quot;hello\u0026quot;后，再改变x的值：x=\u0026quot;world\u0026quot;，会在堆内存中重新划一块内存，储存\u0026quot;world\u0026quot;，并将x指向新内存，原有内存后续如果没有被引用就会被清理掉（垃圾回收）\n然而，若我们string x = \u0026quot;hello后string y = x，y和x指向同一块堆内存\u0026quot;hello\u0026quot;，但是如上一段所说，x=\u0026quot;world\u0026quot;会在堆中新建一块内存，而不是更改原有内存的数据，也就是说，现在，x指向world，而y依然指向hello\n所以对String虽然是引用类型，但是直接使用=等号，是深拷贝\n更详细的证明见这里","title":"Java 中基本类型与引用类型的深拷贝和浅拷贝"},{"content":"假设我们要在一个 vector\u0026lt;int\u0026gt; 中，查找一个数 value\n语法 auto p = std::lower_bound(v.begin(), v.end(), value) auto p = std::upper_bound(v.begin(), v.end(), value) 返回的值类型是 iterator 即迭代器，理解为指针即可\n定义 lower_bound 获取第一个大于等于value的指针\nis not less than\nupper_bound 获取第一个大于 value的指针\nis greater than value\n用法详解 由上可以引申出多种用法：\n要查找的每个数都存在时，如果这个数只存在一次 lower_bound 和 upper_bound - 1 结果一样，同样指向该数，upper_bound 指向第一个大于value的数\n要查找的每个数都存在时，如果这个数存在多次 lower_bound 能查找到左侧边界，upper_bound - 1 能查找到右侧边界\n要查找的数不在时 lower_bound 和 upper_bound 结果一样，同样指向第一个大于value的数\n引申 STL 里面还有一个 equal_range()，就是返回一个pair，分别为 lower_bound 和 upper_bound 的结果\n可以理解为一个左闭右开 [start, end) ，区间为要查找的 vector 里面，等于 value 的部分\n为什么呢，因为 lower_bound 找到第一个等于（如果存在） value 的，upper_bound 找到第一个大于 value 的，所以中间的部分，自然就是等于 value 的部分\n手写二分 若左闭右开区间，则 while (l \u0026lt; r)\n若左闭右闭区间，则 while (l \u0026lt;= r)\n全部 return left\n当寻找 lower_bound 时，向左侧靠拢，left 即为 lower_bound，即第一个大于 val 的\n当寻找 upperr_bound 时，向右侧靠拢，left 即为 upper_bound，即第一个大于 val 的\n","permalink":"https://wy-luke.github.io/posts/binary-search/","summary":"假设我们要在一个 vector\u0026lt;int\u0026gt; 中，查找一个数 value\n语法 auto p = std::lower_bound(v.begin(), v.end(), value) auto p = std::upper_bound(v.begin(), v.end(), value) 返回的值类型是 iterator 即迭代器，理解为指针即可\n定义 lower_bound 获取第一个大于等于value的指针\nis not less than\nupper_bound 获取第一个大于 value的指针\nis greater than value\n用法详解 由上可以引申出多种用法：\n要查找的每个数都存在时，如果这个数只存在一次 lower_bound 和 upper_bound - 1 结果一样，同样指向该数，upper_bound 指向第一个大于value的数\n要查找的每个数都存在时，如果这个数存在多次 lower_bound 能查找到左侧边界，upper_bound - 1 能查找到右侧边界\n要查找的数不在时 lower_bound 和 upper_bound 结果一样，同样指向第一个大于value的数\n引申 STL 里面还有一个 equal_range()，就是返回一个pair，分别为 lower_bound 和 upper_bound 的结果\n可以理解为一个左闭右开 [start, end) ，区间为要查找的 vector 里面，等于 value 的部分","title":"C++ STL 二分 lower_bound / upper_bound 用法详解"}]